// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'club_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ClubState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            PartnerClub club,
            bool lastAvailableDateSelected,
            Activity? selectedActivity,
            FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
            FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
            FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
            List<Batch>? batches)
        loaded,
    required TResult Function(String error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(
            PartnerClub club,
            bool lastAvailableDateSelected,
            Activity? selectedActivity,
            FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
            FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
            FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
            List<Batch>? batches)?
        loaded,
    TResult? Function(String error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            PartnerClub club,
            bool lastAvailableDateSelected,
            Activity? selectedActivity,
            FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
            FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
            FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
            List<Batch>? batches)?
        loaded,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ClubStateLoading value) loading,
    required TResult Function(_ClubStateLoaded value) loaded,
    required TResult Function(_ClubStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ClubStateLoading value)? loading,
    TResult? Function(_ClubStateLoaded value)? loaded,
    TResult? Function(_ClubStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ClubStateLoading value)? loading,
    TResult Function(_ClubStateLoaded value)? loaded,
    TResult Function(_ClubStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClubStateCopyWith<$Res> {
  factory $ClubStateCopyWith(ClubState value, $Res Function(ClubState) then) =
      _$ClubStateCopyWithImpl<$Res, ClubState>;
}

/// @nodoc
class _$ClubStateCopyWithImpl<$Res, $Val extends ClubState>
    implements $ClubStateCopyWith<$Res> {
  _$ClubStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_ClubStateLoadingCopyWith<$Res> {
  factory _$$_ClubStateLoadingCopyWith(
          _$_ClubStateLoading value, $Res Function(_$_ClubStateLoading) then) =
      __$$_ClubStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ClubStateLoadingCopyWithImpl<$Res>
    extends _$ClubStateCopyWithImpl<$Res, _$_ClubStateLoading>
    implements _$$_ClubStateLoadingCopyWith<$Res> {
  __$$_ClubStateLoadingCopyWithImpl(
      _$_ClubStateLoading _value, $Res Function(_$_ClubStateLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_ClubStateLoading extends _ClubStateLoading
    with DiagnosticableTreeMixin {
  const _$_ClubStateLoading() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ClubState.loading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ClubState.loading'));
  }

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            PartnerClub club,
            bool lastAvailableDateSelected,
            Activity? selectedActivity,
            FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
            FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
            FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
            List<Batch>? batches)
        loaded,
    required TResult Function(String error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(
            PartnerClub club,
            bool lastAvailableDateSelected,
            Activity? selectedActivity,
            FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
            FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
            FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
            List<Batch>? batches)?
        loaded,
    TResult? Function(String error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            PartnerClub club,
            bool lastAvailableDateSelected,
            Activity? selectedActivity,
            FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
            FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
            FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
            List<Batch>? batches)?
        loaded,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ClubStateLoading value) loading,
    required TResult Function(_ClubStateLoaded value) loaded,
    required TResult Function(_ClubStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ClubStateLoading value)? loading,
    TResult? Function(_ClubStateLoaded value)? loaded,
    TResult? Function(_ClubStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ClubStateLoading value)? loading,
    TResult Function(_ClubStateLoaded value)? loaded,
    TResult Function(_ClubStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _ClubStateLoading extends ClubState {
  const factory _ClubStateLoading() = _$_ClubStateLoading;
  const _ClubStateLoading._() : super._();
}

/// @nodoc
abstract class _$$_ClubStateLoadedCopyWith<$Res> {
  factory _$$_ClubStateLoadedCopyWith(
          _$_ClubStateLoaded value, $Res Function(_$_ClubStateLoaded) then) =
      __$$_ClubStateLoadedCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {PartnerClub club,
      bool lastAvailableDateSelected,
      Activity? selectedActivity,
      FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
      FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
      FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
      List<Batch>? batches});

  $PartnerClubCopyWith<$Res> get club;
  $ActivityCopyWith<$Res>? get selectedActivity;
}

/// @nodoc
class __$$_ClubStateLoadedCopyWithImpl<$Res>
    extends _$ClubStateCopyWithImpl<$Res, _$_ClubStateLoaded>
    implements _$$_ClubStateLoadedCopyWith<$Res> {
  __$$_ClubStateLoadedCopyWithImpl(
      _$_ClubStateLoaded _value, $Res Function(_$_ClubStateLoaded) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? club = null,
    Object? lastAvailableDateSelected = null,
    Object? selectedActivity = freezed,
    Object? dateSlots = freezed,
    Object? timeSlots = freezed,
    Object? durationSlots = freezed,
    Object? batches = freezed,
  }) {
    return _then(_$_ClubStateLoaded(
      club: null == club
          ? _value.club
          : club // ignore: cast_nullable_to_non_nullable
              as PartnerClub,
      lastAvailableDateSelected: null == lastAvailableDateSelected
          ? _value.lastAvailableDateSelected
          : lastAvailableDateSelected // ignore: cast_nullable_to_non_nullable
              as bool,
      selectedActivity: freezed == selectedActivity
          ? _value.selectedActivity
          : selectedActivity // ignore: cast_nullable_to_non_nullable
              as Activity?,
      dateSlots: freezed == dateSlots
          ? _value.dateSlots
          : dateSlots // ignore: cast_nullable_to_non_nullable
              as FilterGroup<bool, ToggledFilter<DateTime>>?,
      timeSlots: freezed == timeSlots
          ? _value.timeSlots
          : timeSlots // ignore: cast_nullable_to_non_nullable
              as FilterGroup<bool, ToggledFilter<DateTime>>?,
      durationSlots: freezed == durationSlots
          ? _value.durationSlots
          : durationSlots // ignore: cast_nullable_to_non_nullable
              as FilterGroup<bool, ToggledFilter<Duration>>?,
      batches: freezed == batches
          ? _value.batches
          : batches // ignore: cast_nullable_to_non_nullable
              as List<Batch>?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PartnerClubCopyWith<$Res> get club {
    return $PartnerClubCopyWith<$Res>(_value.club, (value) {
      return _then(_value.copyWith(club: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ActivityCopyWith<$Res>? get selectedActivity {
    if (_value.selectedActivity == null) {
      return null;
    }

    return $ActivityCopyWith<$Res>(_value.selectedActivity!, (value) {
      return _then(_value.copyWith(selectedActivity: value));
    });
  }
}

/// @nodoc

class _$_ClubStateLoaded extends _ClubStateLoaded with DiagnosticableTreeMixin {
  const _$_ClubStateLoaded(
      {required this.club,
      required this.lastAvailableDateSelected,
      this.selectedActivity,
      this.dateSlots,
      this.timeSlots,
      this.durationSlots,
      this.batches})
      : super._();

  @override
  final PartnerClub club;
  @override
  final bool lastAvailableDateSelected;
  @override
  final Activity? selectedActivity;
  @override
  final FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots;
  @override
  final FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots;
  @override
  final FilterGroup<bool, ToggledFilter<Duration>>? durationSlots;
  @override
  final List<Batch>? batches;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ClubState.loaded(club: $club, lastAvailableDateSelected: $lastAvailableDateSelected, selectedActivity: $selectedActivity, dateSlots: $dateSlots, timeSlots: $timeSlots, durationSlots: $durationSlots, batches: $batches)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ClubState.loaded'))
      ..add(DiagnosticsProperty('club', club))
      ..add(DiagnosticsProperty(
          'lastAvailableDateSelected', lastAvailableDateSelected))
      ..add(DiagnosticsProperty('selectedActivity', selectedActivity))
      ..add(DiagnosticsProperty('dateSlots', dateSlots))
      ..add(DiagnosticsProperty('timeSlots', timeSlots))
      ..add(DiagnosticsProperty('durationSlots', durationSlots))
      ..add(DiagnosticsProperty('batches', batches));
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClubStateLoadedCopyWith<_$_ClubStateLoaded> get copyWith =>
      __$$_ClubStateLoadedCopyWithImpl<_$_ClubStateLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            PartnerClub club,
            bool lastAvailableDateSelected,
            Activity? selectedActivity,
            FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
            FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
            FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
            List<Batch>? batches)
        loaded,
    required TResult Function(String error) error,
  }) {
    return loaded(club, lastAvailableDateSelected, selectedActivity, dateSlots,
        timeSlots, durationSlots, batches);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(
            PartnerClub club,
            bool lastAvailableDateSelected,
            Activity? selectedActivity,
            FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
            FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
            FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
            List<Batch>? batches)?
        loaded,
    TResult? Function(String error)? error,
  }) {
    return loaded?.call(club, lastAvailableDateSelected, selectedActivity,
        dateSlots, timeSlots, durationSlots, batches);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            PartnerClub club,
            bool lastAvailableDateSelected,
            Activity? selectedActivity,
            FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
            FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
            FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
            List<Batch>? batches)?
        loaded,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(club, lastAvailableDateSelected, selectedActivity,
          dateSlots, timeSlots, durationSlots, batches);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ClubStateLoading value) loading,
    required TResult Function(_ClubStateLoaded value) loaded,
    required TResult Function(_ClubStateError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ClubStateLoading value)? loading,
    TResult? Function(_ClubStateLoaded value)? loaded,
    TResult? Function(_ClubStateError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ClubStateLoading value)? loading,
    TResult Function(_ClubStateLoaded value)? loaded,
    TResult Function(_ClubStateError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _ClubStateLoaded extends ClubState {
  const factory _ClubStateLoaded(
      {required final PartnerClub club,
      required final bool lastAvailableDateSelected,
      final Activity? selectedActivity,
      final FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
      final FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
      final FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
      final List<Batch>? batches}) = _$_ClubStateLoaded;
  const _ClubStateLoaded._() : super._();

  PartnerClub get club;
  bool get lastAvailableDateSelected;
  Activity? get selectedActivity;
  FilterGroup<bool, ToggledFilter<DateTime>>? get dateSlots;
  FilterGroup<bool, ToggledFilter<DateTime>>? get timeSlots;
  FilterGroup<bool, ToggledFilter<Duration>>? get durationSlots;
  List<Batch>? get batches;
  @JsonKey(ignore: true)
  _$$_ClubStateLoadedCopyWith<_$_ClubStateLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ClubStateErrorCopyWith<$Res> {
  factory _$$_ClubStateErrorCopyWith(
          _$_ClubStateError value, $Res Function(_$_ClubStateError) then) =
      __$$_ClubStateErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$_ClubStateErrorCopyWithImpl<$Res>
    extends _$ClubStateCopyWithImpl<$Res, _$_ClubStateError>
    implements _$$_ClubStateErrorCopyWith<$Res> {
  __$$_ClubStateErrorCopyWithImpl(
      _$_ClubStateError _value, $Res Function(_$_ClubStateError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$_ClubStateError(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ClubStateError extends _ClubStateError with DiagnosticableTreeMixin {
  const _$_ClubStateError({required this.error}) : super._();

  @override
  final String error;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ClubState.error(error: $error)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ClubState.error'))
      ..add(DiagnosticsProperty('error', error));
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClubStateErrorCopyWith<_$_ClubStateError> get copyWith =>
      __$$_ClubStateErrorCopyWithImpl<_$_ClubStateError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            PartnerClub club,
            bool lastAvailableDateSelected,
            Activity? selectedActivity,
            FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
            FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
            FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
            List<Batch>? batches)
        loaded,
    required TResult Function(String error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(
            PartnerClub club,
            bool lastAvailableDateSelected,
            Activity? selectedActivity,
            FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
            FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
            FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
            List<Batch>? batches)?
        loaded,
    TResult? Function(String error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            PartnerClub club,
            bool lastAvailableDateSelected,
            Activity? selectedActivity,
            FilterGroup<bool, ToggledFilter<DateTime>>? dateSlots,
            FilterGroup<bool, ToggledFilter<DateTime>>? timeSlots,
            FilterGroup<bool, ToggledFilter<Duration>>? durationSlots,
            List<Batch>? batches)?
        loaded,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ClubStateLoading value) loading,
    required TResult Function(_ClubStateLoaded value) loaded,
    required TResult Function(_ClubStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ClubStateLoading value)? loading,
    TResult? Function(_ClubStateLoaded value)? loaded,
    TResult? Function(_ClubStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ClubStateLoading value)? loading,
    TResult Function(_ClubStateLoaded value)? loaded,
    TResult Function(_ClubStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _ClubStateError extends ClubState {
  const factory _ClubStateError({required final String error}) =
      _$_ClubStateError;
  const _ClubStateError._() : super._();

  String get error;
  @JsonKey(ignore: true)
  _$$_ClubStateErrorCopyWith<_$_ClubStateError> get copyWith =>
      throw _privateConstructorUsedError;
}
